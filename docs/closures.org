#+TITLE: Closures + Binding
* Intro
   - Elisp tiene como característica de utilizar *Dynamic Binding* y *Lexical Binding* (/éste último está desactivado por default en emacs/)
   - Al habilitar el *Lexical Binding* en emacs
     1. las *funciones anónimas* se convierten en *closures*
     2. las funciones pueden capturar lo que se conoce por *ámbito léxico* que es más rápido que el *ámbito dinámico*
* Closures
** Ejemplos Básicos
*** Ejemplo 1
    #+BEGIN_SRC elisp
      ;; habilitamos el Lexical binding
      (setq lexical-binding t)

      ;; imprimimos el nombre de buffer actual
      (prin1-to-string (current-buffer))

      ;; la siguiente función `foo' retorna un closure que retorna el primer argumento
      ;; para que funcione como un `closure' habilitar el `lexical-binding'
      (defun foo (x y)
        (lambda () x))

      (foo :bar :ignored)
      ;; al ejecutar la anterior función el minibuffer imprimirá
      ;; => (closure ((y . :ignored) (x . :bar) t) () x)
    #+END_SRC
*** Ejemplo 2
    #+BEGIN_SRC elisp
      ; habilitamos lexical binding
      (setq lexical-binding t)

      ; definimos una variable que le asignamos una función lambda por tanto podemos ejecutarla como una función
      ; con `funcall'
      ;
      ; 1. con `setq' definimos una variable `test'
      ; 2 con `let' definimos un nuevo contexto que reescribirá el valor de las variables si estas fueran externas
      ; pero sólo dentro de del contexto definido/delimitado por `let'
      ; 2.1 definimos una variable `foo' en el contexto de `let' y le asignamos el string "bar"
      ; 2.2 en el cuerpo de `let' agregamos una función lambda
      ; 2.2.1 la lambda no tiene parámetros, lo usual sería algo del tipo `let (param1 param2 ..) (cuerpo)'
      ; 2.2.2 la lambda tiene en el cuerpo la variable definida por `let' por tanto es lo que retornará la lambda

      ; definimos una variable `foo' y le asignamos el string "bar"
      ; 1.2 ejecutamos una lambda sin parámetros que tiene la variable foo de cuerpo, es lo que devolverá
      (setq test (let ((foo "bar"))
                   (lambda () foo)))
      ; llamamos a la variable `test' con `funcall' como una función porque ésta retorna una lambda
      (funcall test)

      ; si tenemos el lexical binding desactivado, entonces retornará el string "algo"
      (let ((foo "algo")) (funcall test))
    #+END_SRC
*** Ejemplo 3
    #+BEGIN_SRC elisp
      ; habilitamos el lexical binding
      (setq lexical-binding t)

      ;; 1. declaramos dentro del contexto de `let' una variable `foo'
      ;; 2. a la variable `foo' le asignamos una lambda
      ;; 2.1 la lambda no recibe parámetros
      ;; 2.2 el cuerpo de la lambda tiene un string (lo que retornará la lambda)
      ;;
      ;; 3. en el cuerpo de `let' definimos una función `bar'
      ;; 3.1 la función `bar' invoca la variable `foo' como una función porque ésta retorna una lambda
      (let ((foo (lambda () "soy un patito")))
        (defun bar ()
          (funcall foo)))

      ;; si está habilitado el lexical binding devolverá el string "soy un patito" que retorna la lambda asignada a la variable `foo'
      ;; si NO está habilitado, lanzará un error indicando que no está definido `foo' porque sólo vive en el contexto de `let'
      (bar)
    #+END_SRC
** Otros Ejemplos
*** Ejemplo 1 - Contador
    #+BEGIN_SRC elisp
      ;; habilitamos lexical binding
      (setq lexical-binding t)

      ;; creamos un closure, que incrementará el valor de `counter' cada vez que se ejecute la función `counting'
      ;;
      ;; 1. declaramos la variable `counter' dentro del contexto de `let' y le asignamos el entero `0'
      ;; 2. en el cuerpo de `let' definimos una función `counting' que incrementa en 1 el valor de la variable atada a `let'
      ;;
      ;; si no habilitamos el lexical binding, al invocar a `counting' lanzará un error porque no recibe como parámetro
      ;; la variable `counter' de `let' que estaba inicializada en `0'
      (let ((counter 0))
        (defun counting ()
          (setq counter (1+ counter))))

      ;; cada llamada incrementará el valor (suponiendo que está habilitado el lexical binding)
      (counting)
    #+END_SRC
*** Ejemplo 2
    #+BEGIN_SRC elisp
      (setq lexical-binding t)

      (defun bar (n)
        (with-temp-buffer
          (let ((standard-output (current-buffer)))
            (loop for i from 0 to n do (princ i))
            (let ((string (buffer-string)))
              (lambda () string)))))

      (bar 3)
    #+END_SRC
* Binding
** Conceptos
  - Es la relación/enlace entre invocar una *función/método/procedimiento* y su *definición* (/el código que se ejecuta, la implementación/)
  - Hay un *enlace/vínculo* entre la *llamada a una función* (el nombre/identificador) y la *definición de la función* (su implementación)

  #+BEGIN_QUOTE
  En *Binding Dinámico* los nombres de todas la variables y sus valores viven en una única tabla global

  En *Binding Estático* cada *ámbito de scope* (función, sintáxis let, ..) crea una nueva tabla de nombre de variables y valores,
  organizada jerárquicamente conocido como "ámbito" (las variables viven sólo en ese scope/ámbito)
  #+END_QUOTE
** Ejemplos
*** Ejemplo de Binding con let
   #+BEGIN_SRC elisp
     ;; - con `let' podemos crear un `binding' (enlace, vínculo) entre un identificador y su valor
     ;; - declaramos el identificador `nombre' y lo vincula con el valor (un string) "carlitos"
     ;; - el vínculo/enlace creado por `let' vive sólo dentro de su scope/ámbito, fuera de éste deja de existir
     (let ((nombre "carlitos"))
       (print nombre))

     ;; `let' es un "azúcar sintáctico", porque en realidad es una función `lambda'
     ;;
     ;; 1. declaramos dos variables `a' y `b' que viven dentro del ámbito de `let' y le asignamos como valor los enteros `1' y `2'
     ;; 2. en el cuerpo de `let' sumamos los valores de las variables
     (let ((a 1) (b 2)) (+ a b))

     ;; ésta lambda hace lo mismo que el let anterior
     ;;
     ;; 1. recibe dos parámetros `a' y `b'
     ;; 2. en el cuerpo suma sus valores
     ;; 3. le pasamos el valor de los dos parámetros a la lambda `1' y `2'
     ((lambda (a b) (+ a b)) 1 2)
   #+END_SRC
*** Ejemplo de Binding al llamar una función (defun)
   #+BEGIN_SRC elisp
     ;; - una llamada a una función crea un `binding' (enlace, vínculo) para sus parámetros, cuando estos son llamados
     ;; - el vínculo/enlace creado por una llamada a una función, finaliza con su retorno
     (defun saludar (nombre)
       "esta función sólo saludará"
       (let ((nombre "pepito")) (print nombre))
       (print nombre))

     (saludar "carlitos")
   #+END_SRC
*** Ejemplos conceptuales de Binding en Java
    #+BEGIN_QUOTE
    Binding Dinámico
    - En java, al mandar un mensaje a dos objetos polimórficos distintos (/concepto de polimorfismo/)

    Binding Estático
    - En java, un objeto que recibe dos mensajes con el mismo nombre pero distintos parámetros (/concepto de Sobrecarga/)
    #+END_QUOTE
* Dynamic/Virtual Binding (Enlace Dinámico)
** Conceptos
  - En *tiempo de ejecución* se determina/resuelve la relación/enlace de ~(nombre de la funcion, definición de la funcion)~
  - Cuando la determinación de que definición se aplica a un nombre se establece en *tiempo de ejecución*
  - La *velocidad de ejecución es mas lenta* comparado con la *Vinculación Estática*
    (/porque recopila la información necesaria para llamar a una función durante tiempo de ejecución/)

  #+BEGIN_QUOTE
  Un ejemplo de *Binding Dinámico*  puede ocurrir cuando se trabaja con métodos polimorfos en un lenguaje de programación orientada a objetos,
  ya que la *definición completa del tipo del objeto* no se conoce hasta el *momento de la ejecución*
  #+END_QUOTE
** Ejemplo en (OOP) Paradigma Orientado a Objetos
   #+BEGIN_QUOTE
   Si tenemos la clases ~Contador~ y ~Programador~ que heredan los métodos de ~Empleado~ quien declara el método ~trabajar~

   El ~Contador~ y el ~Programador~ entienden el mensaje ~trabajar~ pero cada uno tiene su propia implementación

   Por ejemplo digamos que el jefe les llama la atención y los hace trabajar..
   ~void llamarAtencion(Empleado e){ e.trabajar(); }~

   A simple vista NO se puede determinar la clase de ~e~, puede ser un contador ó un programador,
   podría ser ~Contador.trabajar~ ó ~Programador.trabajar~ 

   Al utilizar *Dynamic Binding* el objeto ~e~ la decisión de *que método ejecutar*,
   se retrasa hasta *tiempo de ejecución* en vez de decidir en *tiempo de compilación*
   #+END_QUOTE
* Static/Lexical Binding (Enlace Estático)
** Conceptos
  - En *tiempo de compilación* se determina/resuelve la relación/enlace de ~(nombre de la funcion, definición de la funcion)~
  - Cuando la determinación de que *definición* (/la implementación, el código en si/) se aplica a un *nombre* se establece en *tiempo de compilación*
  - La vinculación ocurre antes que se ejecute el programa (tiempo de compilación)
  - *La velocidad de ejecución* es mayor comparado con la *Vinculación Dinámica*
    (/porque toda la información se conoce antes de tiempo de ejecución/)

  #+BEGIN_QUOTE
  Un ejemplo de *Binding Estático* es una llamada a una función en C,
  *la función referenciada por un identificador* NO puede cambiarse en *tiempo de ejecución*
  #+END_QUOTE
* Referencias
** Referencias Oficiales
   1. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Variable-Scoping.html][Variable scoping (gnu.org)]]
   1. [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][Dynamic Binding Vs Lexical Binding (emacswiki.org)]]
   2. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][Lexical binding (gnu.org)]]
   3. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Anonymous-Functions.html][Anonymous functions (gnu.org)]]
   2. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][Closures (gnu.org)]]
** Referencias Extraoficiales
   1. [[https://es.sawakinome.com/articles/programming/difference-between-static-binding-and-dynamic-binding.html][Difference between static binding and dynamic binding (sawakinome.com)]]
   2. [[https://www.codingame.com/playgrounds/51214/manejo-dinamico-de-memoria-y-polimorfismo-practica-4/polimorfismo][Manejo dinámico de memoria y polimorfismo (codingame.com)]]
   3. [[https://nullprogram.com/blog/2013/12/30/][Emacs Lisp, readable closures (nullprogram.com)]]
   4. [[https://wiki.uqbar.org/wiki/articles/binding--polimorfismo-y-sobrecarga.html][Binding, Polimorfismo y sobrecarga (uqbar.org)]]
   5. [[http://technical-dresese.blogspot.com/2011/04/brief-demonstration-of-emacs-new.html][Brief demonstration of emacs (technical-dresese.blogspot.com)]]
** Referencias Youtube
   1. [[https://www.youtube.com/watch?v=y2eCjadS8x8][Enlace estático y dinámico (UPV)]]
