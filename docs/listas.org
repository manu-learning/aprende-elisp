#+STARTUP: inlineimages
* Listas
** Conceptos
   - Las listas tienen la sig. sintáxis ~'(elemento1 elemento2 ...)~ ó ~(list elemento1 elemento2 ...)~
   - Para definir una variable y asignarle una lista usamos ~setq~
** Ejemplos
*** Ejemplo 1 - Operaciones básicas
  #+BEGIN_SRC elisp
    ;; Declaramos una variable `numeros' y le asignamos de valor la lista '(1 2 3 4)
    (setq numeros '(1 2 3 4))

    ;; evaluamos la variable
    numeros

    ;; `car' devuelve la cabeza de la lista (el primer elemento)
    (car numeros)

    ;; `cdr' devuelve la cola de la lista (los elementos siguientes al primero)
    (cdr numeros)
    
    ;; obtenemos la cola de la lista, e invertimos el orden
    (reverse (cdr numeros))
  #+END_SRC
*** Ejemplo 2 - Operaciones básicas
  #+BEGIN_SRC elisp
    ;; Lista con 3 elementos
    ;; (al no estar asociada a una variable, no podemos reutilizarla)
    '(1 2 3)

    ;; Lista de 3 elementos con la notación dotted pair (a . b)
    ;; (al no estar asociada a una variable, no podemos reutilizarla)
    '(1 . (2 . (3 . nil)))

    ;; - devuelve un par punteado (a . b)
    ;; - usamos el apóstrofe en cada elemento para declarar una variable con ese identificador
    ;; - como el segundo parámetro de `cons' no es una lista, se crea un par punteado (a . b)
    ;; (al no estar asociada a una variable, no podemos reutilizarlo)
    (cons 'a 'b)

    ;; define una variable `lista' y le asigna la lista '(a b)
    (setq lista '(a b))
    lista

    ;; devuelve una lista con tres elementos '(a b c),
    ;; el último no se muestra porque  es una lista vacia '()
    (cons 'a (cons 'b (cons 'c '())))

    ;; - devuelve una lista con 4 elementos (a b c d)
    ;; - con `const' agregamos la variable `a' declarada al principio de la lista '(b c d)
    (cons 'a '(b c d))

    ;; con `cdr' obtenemos el valor del par punteado (a . b)
    ;; es decir del par clave-valor agarrará el valor que es `b'
    (cdr '(a . b))

    ;; - con `car' obtenemos la clave del par punteado (a . b)
    ;; es decir del par clave-valor agarrará la clave que es `a'
    (car '(a . b))

    ;; - definimos una variable `lista' y le asignamos un par punteado (a . b)
    ;; - como el segundo parámetro de `cons' no es una lista, se crea un par punteado (a . b)
    (setq lista (cons 'a 'b))

    lista
  #+END_SRC
*** Ejemplo 3 - Permutar elementos entre listas
  #+BEGIN_SRC elisp
    ;; Definimos una función que cambia el primer elemento de una lista2, por el primero de lista1
    ;;
    ;; 1. `car' devuelve la cabeza de lista1 (el primer elemento)
    ;; 2. `cdr' devuelve la cola de lista2 (los elementos siguientes al primero)
    ;; 3. `cons' inserta el elemento que devuelve `car lista1' en la lista que devuelve `cdr lista2'
    (defun permutainicio (lista1 lista2)
      (cons (car lista1) (cdr lista2))
      )

    ;; Invocamos la función
    (permutainicio '(1 2 3) '(a b c))
  #+END_SRC
*** Ejemplo 4 - Recortar los extremos de una lista
  #+BEGIN_SRC elisp
    ;; Definimos una función que elimina el primer elemento y el último elemento
    ;;
    ;; 1. Devuelve la cola de la lista (desaparece el primero)
    ;; 2. Invierte el orden de los elementos de la lista (en una nueva lista)
    ;; 3. Devuelve la cola de la nueva lista (desaparece el primero, que al principio era el último)
    ;; 4. Invierte el orden, quedando en el mismo orden que al principio
    (defun recortalista (lista)
      (reverse (cdr (reverse (cdr lista))))
      )

    ;; Invocamos la función
    (recortalista numeros)
  #+END_SRC
*** Ejemplo 5 - Reconocer si una cadena es palíndrome
  #+BEGIN_SRC elisp
    ;; Definimos la función
    (defun es-palindrome (lista)
      (equal lista (reverse lista))
      )

    ;; Invocamos la función
    (es-palindrome "hooh")
  #+END_SRC
* (plist) Listas de Propiedades
** Conceptos
  - Son estructuras de datos similar a los registros/campos en otros lenguajes
  - Persiste lo datos como clave/valor similar a un archivo json
  - La funciones ~plist-put~ y ~plist-get~ comparan las claves de las propiedades usando la función ~eq~
  - Con ~plist-get~ obtenemos una propiedad de la lista de propiedades, uno en particular
  - Con ~plist-put~ busca una propiedad por su nombre/clave
    - si la encuentra modfica el valor
    - si no la encuentra, agrega su clave y valor


  #+BEGIN_QUOTE
  Para más información podemos evaluar lo siguiente ~(info "(elisp) Symbol Properties")~

  Dejamos un extracto interesante de (gnu.org)
  
  A symbol whose name starts with a colon (‘:’) is called a keyword symbol.
  These symbols automatically act as constants, and are normally used only
  by comparing an unknown symbol with a few specific alternatives
  
  These symbols cannot be rebound, nor can their values be changed.
  Any attempt to set or bind nil or t signals a setting-constant error.
  
  These constants are fundamentally different from the constants defined using the defconst special form 
  A defconst form serves to inform human readers that you do not intend to change the value of a variable,
  but Emacs does not raise an error if you actually change it.
  #+END_QUOTE
  - Al invocar la función  ;; cada elemento de la lista es del tipo :clave1 valor :clave2 valor
** Ejemplos
*** Ejemplo 1 - Diferentes maneras de definir Listas de propiedades
   #+BEGIN_SRC elisp
     ;; Definimos una variable `persona'
     ;; y le asignamos una Lista de propiedades
     (setq persona '(:nombre "carlos" :apellido "gimenez"))

     ;; alternativa
     (setq persona (list :nombre "carlos" :apellido "gimenez"))
   #+END_SRC
*** Ejemplo 2 - Crear/Modificar una Lista de propiedades
   #+BEGIN_SRC elisp
     ;; - definimos una variable y le asignamos una Lista de propiedades
     ;; con 3 elementos tipo clave-valor
     ;; - con `setq' es similar a usar `set' pero nos evitamos agregar
     ;; el apóstrofe al nombre de la variable
     (setq personajes '(hulk "bruce banner" deadpool "wade wislon " wolverine "james howlett"))

     ;; Probamos definir variables con `setq' y `set' para que se vea la diferencia
     (setq digimon "agumon")
     (set 'pokemon "pikachu")

     ;; Si evaluamos las variables, el resultado es el mismo
     digimon
     pokemon

     ;; agregamos un elemento
     (plist-put personajes 'iron-man "tony star")

     ;; modificamos un elemento
     (plist-put personajes 'iron-man "tony stark")

     ;; - evaluamos la variable
     ;; - no usamos paréntesis porque sólo sirven para las funciones
     personajes
   #+END_SRC
*** Ejemplo 3 - Obtener el valor de un elemento por su clave/nombre
   #+BEGIN_SRC elisp
     ;; - en ambos ejemplos estamos creando una lista de propiedades
     ;; y pasandola por parámetro, su ciclo de vida termina cuando
     ;; termina de evaluarse cada función
     ;; - quizás lo mejor sería que estuviera definida esa lista
     ;; en otra linea y evitamos repetir lógica además de poder reutilizarla

     ;; obtenemos el valor de la clave `nombre'
     (plist-get '(:nombre "carlitos" :edad 5) 'nombre)

     ;; obtenemos el valor de la clave `edad'
     (plist-get '(nombre "carlitos" edad 5) 'edad)
   #+END_SRC
*** Ejemplo 4 - Crear listas de propiedades + Agregar/Modificar elementos (más detallado)
   #+BEGIN_SRC elisp
     ;; - definimos la lista de propiedades, de tres maneras
     ;; 1º manera: podemos usar la función `list'
     ;; 2º manera: podemos usar con el apóstrofe similar como con las variables
     ;; pero seguido de los paréntesis
     ;; 3º manera: aplica si usamos (list e1 e2 ..) ó '(e1 e2 ..)
     ;; sólo cambiamos el símbolo de cada clave para identificarlas
     (setq estudiante (list 'nombre "fede" 'edad 17))
     (setq estudiante '('nombre "fede" 'edad 17))
     (setq estudiante '(:nombre "fede" :edad 17)) ;; esta suele ser la más común

     ;; con plist-put busca una propiedad por su clave
     ;; - si la encuentra modfica el valor
     ;; - si no la encuentra, agrega su clave y valor

     estudiante ; evaluemos la variable para ver su valor

     ;; buscamos la propiedad por su clave `edad', y modificamos su valor a `18'
     (plist-put estudiante 'edad 18)
     ;(setq estudiante(plist-put estudiante 'edad 18))

     estudiante ; evaluemos la variable para ver su valor

     ;; Agregamos un elemento
     ;; - su nombre/clave es `amigos'
     ;; - su valor es una lista que contiene dos elementos
     (plist-put estudiante 'amigos '("carlitos" "pedrito"))
     ;(setq estudiante (plist-put estudiante 'amigos '("carlitos" "pedrito")))

     estudiante ; evaluemos la variable para ver su valor
   #+END_SRC
** Referencias
*** Referencias Oficiales
   1. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Constant-Variables.html][Constant Variables (gnu.org)]]
   2. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html][Symbol type (gnu.org)]]
   3. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Plist-Access.html][Plist Access (gnu.org)]]
   4. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Plists-and-Alists.html][Property List and Association List (gnu.org)]]
   5. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][Association List (gnu.org)]]
* Celdas Cons (Cons cell)
** Conceptos
  - Una *celda cons* (cons cell) se compone por dos punteros
    1) Se utiliza la función ~car~ para obtener el primer puntero
    2) Se utiliza la función ~cdr~ para obtener el segundo puntero
  - Si se utilizan las *celdas cons* (los punteros) para armar una *lista enlazada*
    1) Se utiliza la función ~car~ para obtener el primer elemento (head, la cabeza)
    2) Se utiliza la función ~cdr~ para obtener el resto de los elementos (tail, la cola)
  - Si armamos una *lista enlazada* se enlaza con el segundo puntero y el último puntero debe apuntar a ~nil~
** Ejemplos
*** Ejemplo 1
   #+BEGIN_SRC elisp
     ;; - devuelve un "par punteado" (x . y)
     ;; - `cons' agrega el primer parámetro al segundo parámetro
     ;;
     ;; Si lo vemos como una lista enlazada
     ;; - x: es el primer elemento, ó la cabeza (head) de la lista
     ;; - y: es el segundo elemento ó la cola (tail) de la lista ó también el resto de los elementos
     ;;
     ;; Si lo vemos como un "par punteado"
     ;; - x: es la clave
     ;; - y: es el valor asociado
     ;;
     ;; Si lo vemos como una "celda cons"
     ;; - x: es el primer puntero
     ;; - y: es el segundo puntero
     (cons 'x 'y)

     ;; obtenemos el primer elemento ó bien la cabeza de la lista
     (car (cons 'x 'y))

     ;; obtenemos el segundo elemento ó bien la cola de la lista
     (cdr (cons 'x 'y))


     ;; - combina las funciones cdr y car así (car (cdr '(1 2 3)))
     ;; - obtiene el primer elemento de la cola de la lista
     (cadr '(1 2 3))
   #+END_SRC
*** Ejemplo 2
   #+BEGIN_SRC elisp
     ;; - Si usamos `cons' y el segundo parámetro NO es una lista,
     ;; entonces se devuelve un "par punteado" ó "celdas cons" con dos punteros
     ;;
     ;; devuelve el par punteado ("a" . 5)
     (cons "a" 5)

     ;; devuelve el par punteado (1 . 2)
     (cons 1 2)

     ;; devuelve el par punteado (a . 5)
     ;; (en el primer parámetro habíamos declarado una variable porque empieza con apóstrofe)
     (cons 'a 5)

     ;; `car' devuelve el 1º puntero del par punteado
     (car '(x . 5))

     ;; `cdr' devuelve el 2º puntero del par punteado
     (cdr '(x . 5))

     ;; --------------------------------------------------------------------------------

     ;; - Si usamos `cons' y el segundo parámetro es una lista,
     ;; el resultado será una lista, insertando el primer parámetro en esa lista
     ;;
     ;; devuelve la lista (1 2 3 4)
     (cons 1 '(2 3 4))

     ;; devuelve la lista (1 2 3 4)
     (cons 1 (list 2 3 4))

     ;; --------------------------------------------------------------------------------

     ;; creamos la lista enlazada '(1 2)
     ;; 1 -> 2 -> NULL
     (cons 1 (cons 2 nil))

     ;; creamos la lista enlazada '(1 2 3)
     ;; 1 -> 2 -> 3 -> NULL
     (cons 1 (cons 2 (cons 3 nil)))

     ;; esto NO crea la lista '(1 2 3) porque le falta el nil
     ;; 1 -> 2 . 3
     (cons 1 (cons 2 3))

     ;; - devuelve una lista enlazada (list 1 2 3 4)
     ;; - Se enlazan los pares punteados, usando el segundo puntero
     ;; - El último puntero contiene a null, como en cualquier lista enlazada
     (cons 1 (cons 2 (cons 3 nil)))
   #+END_SRC
** Referencias
*** Referencias Extraoficiales
   1. [[https://learntutorials.net/es/common-lisp/topic/2622/contras-celdas-y-listas][Contras celdas y listas (learntutorials.net)]]
